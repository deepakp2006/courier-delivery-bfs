<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courier Delivery System with BFS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        canvas {
            border: 1px solid black;
            margin-top: 20px;
        }
        #status {
            margin-top: 20px;
            font-weight: bold;
        }
        .highlight {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Courier Delivery System with BFS</h1>
    <button onclick="startDelivery()">Start Delivery</button>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="status"></div>

    <script>
        function startDelivery() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const deliveryOffice = { x: canvas.width / 2, y: canvas.height / 2 };
            let locations = [];
            let locationCoordinates = [];
            let undeliveredCount = 0;
            let deliveredCount = 0;
            let allDelivered = true;

            // Adjacency list for BFS
            let graph = { 'DeliveryOffice': [] };
            let visited = { 'DeliveryOffice': false };

            // Delivery man image
            const deliveryManImage = new Image();
            deliveryManImage.src = 'https://p1.hiclipart.com/preview/363/476/847/delivery-riding-toy-courier-food-delivery-cargo-scooter-logo-cartoon-transport-png-clipart.jpg'; // Path to your image

            deliveryManImage.onload = function() {
                // Get the number of locations
                const numLocations = parseInt(prompt('Enter the number of locations:'));

                // Collect information for each location
                for (let i = 0; i < numLocations; i++) {
                    const name = prompt(`Enter the name of location ${i + 1}:`);
                    const direction = parseInt(prompt(`Enter the direction in degrees for ${name}:`));
                    const distance = parseInt(prompt(`Enter the distance in kilometers for ${name}:`));
                    locations.push({ name, direction, distance });

                    // Calculate coordinates for the location
                    const angle = direction * Math.PI / 180;
                    const x = deliveryOffice.x + Math.cos(angle) * distance * 50; // Scaling distance
                    const y = deliveryOffice.y - Math.sin(angle) * distance * 50; // Inverted y-axis
                    locationCoordinates.push({ name, x, y });

                    // Update graph for BFS
                    graph[name] = [];
                    visited[name] = false;

                    if (i === 0) {
                        graph['DeliveryOffice'].push(name);
                        graph[name].push('DeliveryOffice');
                    } else {
                        graph[locations[i - 1].name].push(name);
                        graph[name].push(locations[i - 1].name);
                    }
                }

                drawLocations();
                moveDeliveryMan(0);
            };

            function drawLocations() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw delivery office
                ctx.beginPath();
                ctx.arc(deliveryOffice.x, deliveryOffice.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.font = '16px Arial';
                ctx.fillText('Delivery Office', deliveryOffice.x + 10, deliveryOffice.y - 10);

                // Draw locations
                for (const loc of locationCoordinates) {
                    ctx.beginPath();
                    ctx.arc(loc.x, loc.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'blue';
                    ctx.fill();
                    ctx.font = '16px Arial';
                    ctx.fillStyle = 'blue';
                    ctx.fillText(loc.name, loc.x + 10, loc.y - 10);
                }
            }

            function moveToLocation(start, end, onComplete) {
                const stepCount = 100;
                let step = 0;
                const dx = (end.x - start.x) / stepCount;
                const dy = (end.y - start.y) / stepCount;

                function animate() {
                    if (step < stepCount) {
                        step++;
                        const newX = start.x + dx * step;
                        const newY = start.y + dy * step;

                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawLocations();

                        // Draw delivery man during movement
                        ctx.drawImage(deliveryManImage, newX - 15, newY - 15, 30, 30); // Adjust size as needed

                        requestAnimationFrame(animate);
                    } else {
                        onComplete();
                    }
                }

                animate();
            }

            function bfsCycleCheck(graph) {
                let queue = ['DeliveryOffice'];
                visited['DeliveryOffice'] = true;

                while (queue.length > 0) {
                    let node = queue.shift();

                    for (let neighbor of graph[node]) {
                        if (!visited[neighbor]) {
                            visited[neighbor] = true;
                            queue.push(neighbor);
                        } else if (neighbor === 'DeliveryOffice') {
                            return true; // Cycle detected
                        }
                    }
                }
                return false; // No cycle
            }

            function moveDeliveryMan(index) {
                if (index >= locationCoordinates.length) {
                    if (!allDelivered) {
                        // If any delivery was not successful, return to the office
                        moveToLocation(locationCoordinates[locationCoordinates.length - 1], deliveryOffice, () => {
                            drawPaths();
                            const isCycle = bfsCycleCheck(graph);
                            if (isCycle) {
                                alert(`Total undelivered couriers: ${undeliveredCount}. A cycle is formed.`);
                                document.getElementById('status').innerText = `Total undelivered couriers: ${undeliveredCount}. A cycle is formed.`;
                            } else {
                                alert('No cycle is formed.');
                                document.getElementById('status').innerText = 'No cycle is formed.';
                            }
                        });
                    } else {
                        // All deliveries were successful, end of the route
                        drawPaths(); // Draw paths for locations even if no cycle
                        alert('All couriers delivered. No cycle formed.');
                        document.getElementById('status').innerText = 'All couriers delivered. No cycle formed.';
                    }
                    return;
                }

                const currentLocation = locationCoordinates[index];
                moveToLocation(index === 0 ? deliveryOffice : locationCoordinates[index - 1], currentLocation, () => {
                    // Draw the path to the current location
                    if (index > 0 || (index === 0 && !allDelivered)) {
                        ctx.beginPath();
                        ctx.moveTo(index === 0 ? deliveryOffice.x : locationCoordinates[index - 1].x, index === 0 ? deliveryOffice.y : locationCoordinates[index - 1].y);
                        ctx.lineTo(currentLocation.x, currentLocation.y);
                        ctx.strokeStyle = 'green';
                        ctx.stroke();
                    }

                    // Once the delivery man reaches the location, ask for delivery status
                    const status = prompt(`Delivery status at ${currentLocation.name} (yes/no):`);
                    if (status.toLowerCase() === 'no') {
                        undeliveredCount++;
                        allDelivered = false;
                    } else {
                        deliveredCount++;
                    }

                    // Move to the next location after a short delay
                    setTimeout(() => moveDeliveryMan(index + 1), 1000); // Delay for demonstration
                });
            }

            function drawPaths() {
                // Draw paths between locations after the cycle is formed or route completed
                for (let i = 0; i < locationCoordinates.length - 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(locationCoordinates[i].x, locationCoordinates[i].y);
                    ctx.lineTo(locationCoordinates[i + 1].x, locationCoordinates[i + 1].y);
                    ctx.strokeStyle = 'green';
                    ctx.stroke();
                }

                // Draw the path back to the office after cycle is formed
                if (!allDelivered && locationCoordinates.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(locationCoordinates[locationCoordinates.length - 1].x, locationCoordinates[locationCoordinates.length - 1].y);
                    ctx.lineTo(deliveryOffice.x, deliveryOffice.y);
                    ctx.strokeStyle = 'green';
                    ctx.stroke();
                }

                // Draw the initial path from the source to the first location if not already drawn
                ctx.beginPath();
                ctx.moveTo(deliveryOffice.x, deliveryOffice.y);
                ctx.lineTo(locationCoordinates[0].x, locationCoordinates[0].y);
                ctx.strokeStyle = 'green';
                ctx.stroke();
            }
        }
    </script>
</body>
</html>
